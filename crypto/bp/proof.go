package bp

import (
	"errors"
	"math"
	"math/big"

	"github.com/actuallyachraf/algebra/ec"
	"github.com/actuallyachraf/algebra/nt"
	"golang.org/x/crypto/sha3"
)

// InnerProdArgument represents the argument (witness) to the inner product
// proof part.
// The protocol implemented for the inner product argument is documented in
// page 16 of the reference paper.
type InnerProdArgument struct {
	L         []*ec.Point
	R         []*ec.Point
	A         *nt.Integer
	B         *nt.Integer
	Challenge []*nt.Integer
}

// NewInnerProductArg creates a new memory allocated instance of said struct
func NewInnerProductArg(size int) InnerProdArgument {
	L := make([]*ec.Point, size)
	R := make([]*ec.Point, size)
	A := new(nt.Integer)
	B := new(nt.Integer)
	C := make([]*nt.Integer, size)

	return InnerProdArgument{
		L:         L,
		R:         R,
		A:         A,
		B:         B,
		Challenge: C,
	}
}

// GenArgParams creates a new set of parameters for the inner product argument
func GenArgParams(params *Parameters, G, H []*ec.Point, x *nt.Integer, L, R, P *ec.Point) ([]*ec.Point, []*ec.Point, *ec.Point) {

	if len(G) != len(H) {
		panic("bad generator vectors")
	}
	splitIndex := len(G) / 2

	GVec := make([]*ec.Point, splitIndex)
	HVec := make([]*ec.Point, splitIndex)

	xInv := nt.ModInv(x, params.L)

	// The new parameters are generated by computing xInv*G[:index] + x*G[index:]
	for i := range GVec {
		GVec[i] = params.EC.Add(params.EC.ScalarMul(G[i], xInv), params.EC.ScalarMul(G[i+splitIndex], x))
		HVec[i] = params.EC.Add(params.EC.ScalarMul(H[i], x), params.EC.ScalarMul(H[i+splitIndex], xInv))
	}
	xSquared := nt.Mod(nt.Mul(x, x), params.L)
	xSquaredInv := nt.ModInv(xSquared, params.L)

	Pprime := params.EC.Add(params.EC.Add(params.EC.ScalarMul(L, xSquared), P), params.EC.ScalarMul(R, xSquaredInv))

	return GVec, HVec, Pprime
}

// GenInnerProdArg builds an argument of knowledge c = <a,b>
// the procedure is ran recursively.
func GenInnerProdArg(params *Parameters, G, H []*ec.Point, a, b Vector, u *ec.Point, P *ec.Point) *InnerProdArgument {

	round := 0
	n := a.Len()

	loglen := int(math.Log2(float64(n)))

	challenges := make([]*big.Int, loglen+1)
	Lvals := make([]*ec.Point, loglen)
	Rvals := make([]*ec.Point, loglen)
	var aPrime = NewVector(a)
	var bPrime = NewVector(b)

	// Fiat Shamir transform challenge is the hash value of L,R
	concat := func(a ...[]byte) []byte {
		c := make([]byte, 0, len(a)*2)

		for _, v := range a {
			c = append(c, v...)
		}
		return c
	}
	for n > 1 {
		n = n / 2
		cL, _ := aPrime[:n].InnerProdMod(bPrime[n:], params.L)
		cR, _ := aPrime[n:].InnerProdMod(bPrime[:n], params.L)
		// commitment to L
		comL := DoubleVectorPedersenCommitmentWithGen(params, G[n:], H[:n], aPrime[:n], bPrime[n:])
		L := params.EC.Add(comL, params.EC.ScalarMul(u, cL))

		// commitment to R
		comR := DoubleVectorPedersenCommitmentWithGen(params, G[:n], H[n:], aPrime[n:], bPrime[:n])
		R := params.EC.Add(comR, params.EC.ScalarMul(u, cR))

		Lvals[round] = L
		Rvals[round] = R

		hashChallenge := sha3.Sum256(
			concat(L.Bytes(), R.Bytes()),
		)
		challengeScalar := new(nt.Integer).SetBytes(hashChallenge[:])
		challengeScalar.Mod(challengeScalar, params.L)
		challenges[round] = new(nt.Integer).SetBytes(challengeScalar.Bytes())

		challengeScalarInv := nt.ModInv(challengeScalar, params.L)

		// generate new round generators
		G, H, P = GenArgParams(params, G, H, challengeScalar, L, R, P)

		aPrime1, err := aPrime[:n].ScalarMulMod(challengeScalar, params.L)
		if err != nil {
			panic(err)
		}
		aPrime2, err := aPrime[n:].ScalarMulMod(challengeScalarInv, params.L)
		if err != nil {
			panic(err)
		}

		aPrime, err = aPrime1.Add(aPrime2)
		if err != nil {
			panic(err)
		}
		bPrime1, err := bPrime[:n].ScalarMulMod(challengeScalar, params.L)
		if err != nil {
			panic(err)
		}
		bPrime2, err := bPrime[n:].ScalarMulMod(challengeScalarInv, params.L)
		if err != nil {
			panic(err)
		}
		bPrime, err = bPrime1.Add(bPrime2)
		if err != nil {
			panic(err)
		}
		round++
	}
	return &InnerProdArgument{Lvals, Rvals, aPrime[0], bPrime[0], challenges}

	/*
		// fix both iterators
		curIt := uint64(math.Log2(float64(a.Len()))) - 1
		nPrime := a.Len() / 2

		cL, _ := a[:nPrime].InnerProdMod(b[nPrime:], params.L)
		cR, _ := a[nPrime:].InnerProdMod(b[:nPrime], params.L)
		// commitment to L
		comL := DoubleVectorPedersenCommitmentWithGen(params, G[nPrime:], H[:nPrime], a[:nPrime], b[nPrime:])
		L := params.EC.Add(comL, params.EC.ScalarMul(u, cL))
		// commitment to R
		comR := DoubleVectorPedersenCommitmentWithGen(params, G[:nPrime], H[nPrime:], a[nPrime:], b[:nPrime])
		R := params.EC.Add(comR, params.EC.ScalarMul(u, cR))

		arg.L[curIt] = L
		arg.R[curIt] = R

		// Fiat Shamir transform challenge is the hash value of L,R
		concat := func(a ...[]byte) []byte {
			c := make([]byte, 0, len(a)*2)

			for _, v := range a {
				c = append(c, v...)
			}
			return c
		}
		hashChallenge := sha3.Sum256(
			concat(L.Bytes(), R.Bytes()),
		)
		challengeScalar := new(nt.Integer).SetBytes(hashChallenge[:])
		challengeScalarInv := nt.ModInv(challengeScalar, params.L)
		arg.Challenge[curIt] = challengeScalar

		// generate new round generators
		Gprime, Hprime, Pprime := GenArgParams(params, G, H, challengeScalar, L, R, P)

		aPrime1, _ := a[:nPrime].ScalarMulMod(challengeScalar, params.L)
		aPrime2, _ := a[nPrime:].ScalarMulMod(challengeScalarInv, params.L)
		aPrime, _ := aPrime1.Add(aPrime2)

		bPrime1, _ := b[:nPrime].ScalarMulMod(challengeScalar, params.L)
		bPrime2, _ := b[nPrime:].ScalarMulMod(challengeScalarInv, params.L)
		bPrime, _ := bPrime1.Add(bPrime2)

		return GenInnerProdArg(params, arg, Gprime, Hprime, aPrime, bPrime, u, Pprime)
	*/
}

// ProveInnerProdArg runs the recursive subroutine
func ProveInnerProdArg(params *Parameters, a []*nt.Integer, b []*nt.Integer, c *nt.Integer, P, U *ec.Point, G, H []*ec.Point) *InnerProdArgument {
	// randomly generate a challenge scalar
	challengeHash := sha3.Sum256(P.Bytes())
	challengeScalar := new(nt.Integer).SetBytes(challengeHash[:])

	xC := nt.ModMul(challengeScalar, c, params.L)
	uS := params.EC.ScalarMul(U, xC)
	Pprime := params.EC.Add(P, U)
	return GenInnerProdArg(params, G, H, a, b, uS, Pprime)
}

// VerifyInnerProdArg verifies a given inner product argument outputs accepts or rejects
func VerifyInnerProdArg(params *Parameters, c *nt.Integer, P, u *ec.Point, GVec, HVec []*ec.Point, ip InnerProdArgument) (bool, error) {
	// compute the first challenge
	challengeHash := sha3.Sum256(P.Bytes())
	challengeScalar := new(nt.Integer).SetBytes(challengeHash[:])

	uS := params.EC.ScalarMul(u, challengeScalar)

	// proof iterator
	iter := len(ip.Challenge) - 1

	if ip.Challenge[iter].Cmp(challengeScalar) != 0 {
		return false, errors.New("bad challenge scalar")
	}

	iter--

	Gprime := make([]*ec.Point, len(GVec))
	copy(Gprime, GVec)

	Hprime := make([]*ec.Point, len(HVec))
	copy(Hprime, HVec)

	Pprime := params.EC.Add(P, params.EC.ScalarMul(uS, c))

	concat := func(a ...[]byte) []byte {
		c := make([]byte, 0, len(a)*2)

		for _, v := range a {
			c = append(c, v...)
		}
		return c
	}

	for iter >= 0 {

		L := ip.L[iter]
		R := ip.R[iter]

		challengeHash2 := sha3.Sum256(concat(L.Bytes(), R.Bytes()))
		challengeScalar2 := new(nt.Integer).SetBytes(challengeHash2[:])

		if ip.Challenge[iter].Cmp(challengeScalar2) != 0 {
			return false, errors.New("bad challenge scalar")
		}

		Gprime, Hprime, Pprime = GenArgParams(params, Gprime, Hprime, challengeScalar2, L, R, Pprime)

		iter--
	}

	// check final challenge commitment
	prodCom := nt.ModMul(ip.A, ip.B, params.L)

	rhs := params.EC.ScalarMul(uS, prodCom)
	lhs := pedersenCom(params, Gprime[0], Hprime[0], ip.A, ip.B)

	Parg := params.EC.Add(lhs, rhs)

	if !Pprime.Equal(Parg) {
		return false, errors.New("bad P' value")
	}
	return true, nil
}
